---
title: Zusammenfassung Betriebssysteme
layout: default
permalink: Semester_4/Betriebssysteme/Zusammenfassung

---

<h1 id="zusammenfassung-betriebssysteme">Zusammenfassung Betriebssysteme</h1>
<p><em>geschrieben von Morten Terhart am 24.03.2018</em></p>
<hr>
<h2 id="einführung">Einführung</h2>
<h3 id="was-ist-ein-betriebssystem">Was ist ein Betriebssystem?</h3>
<blockquote>
<p><em>“Als Betriebssystem bezeichnet man die Software, die den Ablauf von Programmen auf der Hardware steuert und die vorhandenen Betriebsmittel verwaltet.”</em></p>
</blockquote>
<p>Siehe dazu folgendes Schema:<br>
<img src="images/Definition_Betriebssystem.png" alt="Definition Betriebssystem"><br>
<em>Abbildung 1: Einordnung des Betriebssystems in die Abstraktionsebenen eines Rechners</em></p>
<h3 id="anforderungen-an-ein-betriebssystem">Anforderungen an ein Betriebssystem</h3>
<ul>
<li>hohe Zuverlässigkeit</li>
<li>hohe Benutzerfreundlichkeit</li>
<li>geringe Kosten</li>
<li>hohe Leistung</li>
<li>einfache Wartbarkeit</li>
</ul>
<h3 id="betriebsarten-von-betriebssystem">Betriebsarten von Betriebssystem</h3>
<ol>
<li>Klassifikation nach Art der Auftragsbearbeitung
<ul>
<li>Stapelverarbeitung</li>
<li>Interaktiver Betrieb</li>
<li>Echtzeitbetrieb</li>
</ul>
</li>
<li>Weitere Möglichkeit der Klassifikation
<ul>
<li>Einbenutzer- / Mehrbenutzerbetrieb</li>
<li>Einprogramm- / Mehrprogrammbetrieb</li>
<li>Einprozessor- / Mehrprozessorbetrieb</li>
</ul>
</li>
</ol>
<h3 id="aufgaben-eines-betriebssystems">Aufgaben eines Betriebssystems</h3>
<ul>
<li>Steuerung der Eingabe- / Ausgabe-Geräte (u.a. Treiber)</li>
<li>Bereitstellung eines Dateisystems</li>
<li>Benutzerschnittstelle</li>
<li>Verwaltung der Betriebsmittel bei Mehrprogrammbetrieb</li>
<li>Schutz der Anwenderprogramme bei Mehrprogrammbetrieb</li>
</ul>
<h3 id="dienste-eines-betriebssystems">Dienste eines Betriebssystems</h3>
<ul>
<li>Benutzerschnittstelle (Kommandozeile)</li>
<li>Programmausführung</li>
<li>Ein- und Ausgabeoperationen</li>
<li>Dateiverwaltung</li>
<li>Kommunikation (z.B. mit Ein- / Ausgabegeräten oder mit Speicher)</li>
<li>Fehlerbehandlung / Schutzmechanismen</li>
</ul>
<h3 id="einblick-in-unix">Einblick in UNIX</h3>
<p><img src="images/UNIX-components.png" alt="Komponenten von UNIX"><br>
<em>Abbildung 2: Komponenten von UNIX (oben: Benutzerschnittstelle, unten: System- und Hardwareschicht und Kernel)</em></p>
<ul>
<li>System- und Benutzerprogramme werden auf gleicher Ebene als Prozesse ausgeführt, haben aber unterschiedliche Zugriffsrechte</li>
<li>Ein- / Ausgabegeräte werden logisch getrennt behandelt</li>
</ul>
<h3 id="unterbrechungen-interrupts">Unterbrechungen (<em>Interrupts</em>)</h3>
<ul>
<li><strong>Ziel</strong>: Direktes Reagieren auf Ereignisse wie Benutzereingaben durch Unterbrechung eines aktiven Prozesses, Parallelität von Ein- / Ausgabe und Programmausführung
<ul>
<li>Dazu wird der Zustand des Prozesses im Hauptspeicher zwischengespeichert und nach Beendigung der Unterbrechung wiederhergestellt.</li>
</ul>
</li>
<li><strong>Idee</strong>: Prozessor initialisiert Ein- / Ausgabe, sodass E/A-Werk ein Programm selbstständig ausführen kann</li>
</ul>
<p><strong>2 Arten der Unterbrechung</strong>:</p>
<ul>
<li><strong>externe Unterbrechung</strong>: E/A-Werk informiert den Prozessor über Zustand eines E/A-Geräts</li>
<li><strong>interne Unterbrechung</strong>: Prozessor führt Ausnahmebehandlungen bei Fehlern durch (z.B. Division durch 0)</li>
</ul>
<p><strong>Ablauf einer Unterbrechung</strong>:</p>
<ul>
<li>Unterbrechungen werden nur <strong>nach</strong> einer Instruktion behandelt
<ul>
<li>Instruktionen werden nicht unterbrochen</li>
</ul>
</li>
</ul>
<p><img src="images/interrupt-sequence.png" alt="Ablauf einer Unterbrechung"><br>
<em>Abbildung 3: Durchführung einer Unterbrechungssequenz</em><br>
<code>PC</code> = Program Counter</p>
<h2 id="prozesse">Prozesse</h2>
<h3 id="definition">Definition</h3>
<blockquote>
<p><em>“Ein Prozess ist ein Programm während der Ausführung im Arbeitsspeicher einschließlich seiner Umgebung.”</em></p>
</blockquote>
<h3 id="umgebung-eines-prozessors">Umgebung eines Prozessors</h3>
<ul>
<li>Inhalt vom Programmzähler (<code>PC</code>)</li>
<li>Inhalt von Daten-, Adress- und Statusregistern</li>
<li>Daten im Speicher</li>
<li>Programmcode</li>
</ul>
<h3 id="verhalten-eines-prozesses">Verhalten eines Prozesses</h3>
<ul>
<li>ein Prozess (= Eltern-Prozess) kann einen neuen Prozess erzeugen (= Kind-Prozess)</li>
<li>Prozesse können unterbrochen werden</li>
<li>auf einem Prozessor kann <strong>nur ein</strong> Prozess gleichzeitig ausgeführt werden</li>
</ul>
<h3 id="zustände-eines-prozesses">Zustände eines Prozesses</h3>
<ul>
<li><strong>bereit</strong> (<em>ready</em>): Prozess ist ausführbar, Prozessor ist aber belegt</li>
<li><strong>aktiv</strong> (<em>running</em>): Prozess wird auf Prozessor ausgeführt</li>
<li><strong>blockiert</strong> (<em>blocked</em>): Prozess wartet auf ein externes Ereignis <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>q</mi></mrow><annotation encoding="application/x-tex">q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.03588em;">q</span></span></span></span></span></li>
<li><strong>inaktiv</strong> (<em>idle</em>): Prozess wurde erzeugt oder ist terminiert.</li>
</ul>
<p><img src="images/process-status-schema.png" alt="Zustandsübergänge eines Prozesses"><br>
<em>Abbildung 4: Zustandsübergänge eines Prozesses</em></p>
<ul>
<li><strong>Scheduler</strong> steuert die Übergänge <em>assign</em>/<em>deassign</em> und weist Prozesse damit der CPU zu</li>
<li>eigene Warteschlangen für <em>ready</em> und <em>blocked</em>
<ul>
<li><em>ready</em>-Prozesse werden in der Reihenfolge ihrer Ankunft bearbeitet</li>
<li><em>blocked</em>-Prozesse warten auf ein Ereignis, das sie wieder ans Ende der Bereit-Warteschlange stellt</li>
</ul>
</li>
</ul>
<p><img src="images/process-queues.png" alt="Prozesszustände und Warteschlangen"><br>
<em>Abbildung 5: Prozesszustände und Warteschlangen</em></p>
<ul>
<li>bei Prozesswechsel müssen die Registerinhalte des vorherigen Prozesses auf dem Stack gesichert werden</li>
</ul>
<h2 id="prozessverwaltung">Prozessverwaltung</h2>
<ul>
<li><strong>Prozessverwaltung</strong>: Komponente eines Betriebssystems, die für die Zuteilung von Betriebsmitteln an wartende Prozesse zuständig ist</li>
<li>alle für die Prozessverwaltung wichtigen Informationen sind im <strong>Prozessleitblock</strong> hinterlegt</li>
<li>die Leitblöcke aller Prozesse sind in einer Systemprozesstabelle angegeben</li>
</ul>
<h3 id="steuerung-von-prozessen">Steuerung von Prozessen</h3>
<ul>
<li>Der <strong>Scheduler</strong> entscheidet nach einer Strategie, welcher Prozess wann und wie lange ausgeführt werden darf.</li>
<li>verschiedene Strategien zur bestmöglichen Ausnutzung der CPU</li>
<li>Ziele aller Strategien:
<ul>
<li>hohe Auslastung der CPU</li>
<li>hoher Durchsatz an Prozessen</li>
<li>größtmögliche Effektivität (geringste Gesamtwartezeit)</li>
<li>kurze Antwortzeiten</li>
</ul>
</li>
</ul>
<h3 id="scheduling-strategien">Scheduling-Strategien</h3>
<p><strong>2 Arten von Strategien</strong>:</p>
<ul>
<li><strong>non-preemptive</strong> (kooperative) Strategien: Prozess läuft so lange, bis er terminiert oder auf ein Ereignis wartet (<em>blocked</em>)</li>
<li><strong>preemptive</strong> (verdrängende) Strategien: aktiver Prozess kann vom Scheduler aus der CPU gezogen und wieder in die Warteschlange eingeordnet werden</li>
</ul>
<p>Moderne Betriebssysteme verwenden ausschließlich preemptive Strategien.</p>
<h3 id="non-preemptive-scheduling-strategien">Non-preemptive Scheduling-Strategien</h3>
<ul>
<li><em>First Come, First Serve</em> (FCFS)
<ul>
<li>Prozesse werden in der Reihenfolge ihrer Initiierung in die Warteschlange geordnet, diese wird nach dem FIFO-Prinzip (<em>First In, First Out</em>) bearbeitet.<br>
<img src="images/first-come-first-serve.png" alt="Non-preemptive Strategie First Come, First Serve"><br>
<em>Abbildung 6: Scheduling-Strategie “First Come, First Serve”</em></li>
</ul>
</li>
<li><em>Shortest Job First</em> (SJF)
<ul>
<li>Prozesse mit geringsten Bedienzeiten werden zuerst behandelt.</li>
<li>Ziel: Durchschnittliche Antwortzeit reduzieren</li>
<li>Prozesse können bei hohen Prozess-Aufkommen “verhungern”</li>
</ul>
</li>
<li><em>Highest Response Ratio Next</em> (HRRN)
<ul>
<li>Bevorzugt Prozesse mit höheren Antworzeit / Bedienzeit Verhältnissen</li>
</ul>
</li>
<li><em>Priority Scheduling</em> (PS)
<ul>
<li>jeder Prozess <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.65952em;"></span><span class="strut bottom" style="height: 0.65952em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit">i</span></span></span></span></span> hat eine Priorität <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span></li>
<li>Bereit-Warteschlange wird nach Priorität sortiert und nach FIFO-Prinzip bearbeitet.</li>
</ul>
</li>
</ul>
<h3 id="preemptive-scheduling-strategien">Preemptive Scheduling-Strategien</h3>
<ul>
<li><em>Round Robin</em> (RR)
<ul>
<li>Zeitscheibenverfahren mit erhaltener Prozessreihenfolge durch FCFS</li>
<li>jeder Prozess ist für eine festgelegte Zeit <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>t</mi><mtext>slice</mtext></msub></mrow><annotation encoding="application/x-tex">t_{\text{slice}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.61508em;"></span><span class="strut bottom" style="height: 0.76508em; vertical-align: -0.15em;"></span><span class="base"><span class="mord"><span class="mord mathit">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.336108em;"><span class="" style="top: -2.55em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mathrm mtight">slice</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span></span></span></span></span> aktiv und wird danach wieder ans Ende der Warteschlange angehängt<br>
<img src="images/round-robin.png" alt="Scheduling-Strategie Round Robin"><br>
<em>Abbildung 7: Scheduling-Strategie “Round Robin”</em></li>
</ul>
</li>
<li><em>Dynamic Priority Round Robin</em> (DPRR)
<ul>
<li>Round Robin mit priorisierter Warteschlange wie bei PS</li>
<li>Priorität wird bei jedem Durchgang erhöht</li>
</ul>
</li>
<li><em>Shortest Remaining Time First</em> (SRTF)
<ul>
<li>nach jeder Unterbrechung erhält der Prozess mit der niedrigsten verbleibenden Ausführungszeit die CPU</li>
<li>Problem: Restzeit ist oft schwer abzuschätzen</li>
</ul>
</li>
</ul>
<h3 id="prozess-scheduling-in-unix">Prozess-Scheduling in UNIX</h3>
<ul>
<li><em>Round Robin</em> kombiniert mit dynamischen Prioritäten</li>
<li>jede Priorität hat seine eigene Warteschlange und die höchsten Prioritäten werden zuerst bearbeitet</li>
</ul>
<p><img src="images/unix-scheduling-model.png" alt="Prozessplanung unter UNIX"><br>
<em>Abbildung 8: Prozessplanung unter UNIX</em></p>
<h3 id="prozesshierarchie">Prozesshierarchie</h3>
<ul>
<li>Ein Prozess kann einen neuen Prozess auslösen
<ul>
<li>Vater-Prozess (<em>parent process</em>) <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> Kind-Prozess (<em>child process</em>)</li>
</ul>
</li>
<li>Eltern- und Kindprozesse können miteinander kommunizieren</li>
<li>Bei Abschluss des Elternprozesses werden üblicherweise alle Kindprozesse geschlossen</li>
</ul>
<h2 id="threads-und-prozesse">Threads und Prozesse</h2>
<ul>
<li>konventionelle Prozesse kombinieren Ressourcenverwaltung und internes Scheduling</li>
<li>Entkopplung durch
<ul>
<li>Prozess <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> Ressourcenverwaltung, virtueller Adressraum</li>
<li>Thread <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> Zuweisung eines Kind-Prozesses zur CPU (<em>Dispatching</em>)
<ul>
<li>Ausführungszustand (<em>running</em>, <em>ready</em>, …)</li>
<li>Kontext</li>
<li>Stack</li>
<li>eigenes Prozessverwaltungssystem innerhalb des Prozesses</li>
</ul>
</li>
</ul>
</li>
<li><strong>Multithreading</strong>: Innerhalb eines Prozesses werden mehrere Tätigkeiten parallel vorgenommen, setzt Fähigkeit des Betriebssystem zum Multithreading voraus.</li>
</ul>
<h2 id="kommunikation-zwischen-prozessen">Kommunikation zwischen Prozessen</h2>
<p>Prozesse müssen ständig miteinander kommunizieren, z.B. für den Aufbau von <strong>Pipelines</strong> (Übergabe der Ausgabe des vorherigen Prozesses an den nächsten Prozess).</p>
<h3 id="möglichkeiten-der-prozesskommunikation">Möglichkeiten der Prozesskommunikation</h3>
<ul>
<li>Nutzung eines gemeinsamen Speicherbereiches</li>
<li>Kommunikation über Dateien im Dateisystem</li>
<li>expliziter Austausch von Nachrichten</li>
<li>Kommunikation über <em>Pipes</em> (UNIX-spezifisch)</li>
</ul>
<p>Eine sichere Prozesskommunikation bedarf einer geeigneten Prozesssynchronisation, um den gegenseitigen Ausschluss umzusetzen.</p>
<p><strong>Problem</strong>: mehrere Prozesse greifen gleichzeitig auf eine gemeinsame Ressource zu (z.B. Speichervariable)</p>
<p>Code-Abschnitte, die nicht unterbrochen werden <strong>dürfen</strong>, weil sie bspw. eine Transaktion tätigen, bezeichnet man als <strong>kritischen Abschnitt</strong>. Daher dürfen sich mehrere Prozesse nicht gleichzeitig in ihren kritischen Abschnitten befinden.</p>
<h3 id="bedingungen-für-den-gegenseitigen-ausschluss-mutual-exclusion">Bedingungen für den gegenseitigen Ausschluss (<em>mutual exclusion</em>)</h3>
<ol>
<li>Nur ein Prozess darf sich im kritischen Abschnitt befinden.</li>
<li>Prozesse, die in den kritischen Abschnitt eintreten oder diesen verlassen, müssen die anderen wartenden Prozesse über dieses Ereignis informieren.</li>
<li>Auch bei mehr als 2 Prozessen muss das Verfahren einwandfrei sein.</li>
<li>Jeder Prozess soll gleiche Chancen auf den Eintritt in einen kritischen Abschnitt haben.</li>
<li>Kein Prozess in einem kritischen Abschnitt darf andere blockieren.</li>
<li>Kein Prozess soll unendlich lange warten müssen.</li>
</ol>
<h3 id="unterbrechungssperre">Unterbrechungssperre</h3>
<p><strong>Idee</strong>: Unterbrechungen (<em>Interrupts</em>) werden bei Ausführungen eines kritischen Abschnitts ignoriert / maskiert. Selbst das Betriebssystem kann den laufenden Prozess nicht anhalten.</p>

<table>
<thead>
<tr>
<th align="left">Vorteile</th>
<th align="left">Nachteile</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">+ einfache Realisierung</td>
<td align="left">- Anwender muss Maskierung wieder aufheben (kann leicht vergessen werden)</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">- hohe Reaktionszeit bei eintreffenden E/A-Unterbrechungsanforderungen können zu Datenverlust führen</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">- funktioniert nicht bei Mehrprozessorbetrieb</td>
</tr>
</tbody>
</table><h3 id="verwendung-eines-semaphors">Verwendung eines Semaphors</h3>
<p><strong>Definition</strong>: Ein Semaphor (DIJKSTRA, 1965) ist eine Variable <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span>, auf der die zwei folgenden ununterbrechenbaren Operationen <code>P</code> (Passieren) und <code>V</code> (Verlassen) definiert sind:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* do nothing */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> S <span class="token operator">=</span> S <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">]</span>
<span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span> S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">]</span>
</code></pre>
<p>Initialisierung mit <code>S = 1</code>.</p>
<p><strong>Implementation</strong>:</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token keyword">int</span> S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// Zahl der verfügbaren Betriebsmittel</span>
<span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// kritischer Abschnitt hier</span>
<span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p><strong>Nachteil</strong>: rechenintensive Warteschleife in <code>P(S)</code> (<em>busy wait loop</em>)</p>
<p><strong>effizientere Implementation</strong> mit <code>S</code> als Objekt mit den Attributen <code>ctr</code> (Wert des Semaphors) und <code>list</code> (Liste wartender Prozesse):</p>
<pre class=" language-java"><code class="prism  language-java"><span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span> S<span class="token punctuation">.</span>ctr <span class="token operator">=</span> S<span class="token punctuation">.</span>ctr – <span class="token number">1</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ctr <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              put pid in S<span class="token punctuation">.</span>list<span class="token punctuation">;</span>
              <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> 
        <span class="token punctuation">]</span>
<span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token operator">:</span><span class="token operator">=</span> <span class="token punctuation">[</span> S<span class="token punctuation">.</span>ctr <span class="token operator">=</span> S<span class="token punctuation">.</span>ctr <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>ctr <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              get pid from S<span class="token punctuation">.</span>list<span class="token punctuation">;</span>
              <span class="token function">wakeUp</span><span class="token punctuation">(</span>pid<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">]</span>
</code></pre>
<p>Systemaufruf <code>sleep()</code> blockiert Prozess <code>pid</code> und verbraucht so keine CPU-Zeit mehr, bis er durch <code>wakeUp(pid)</code> wieder reaktiviert wird.</p>
<h3 id="erzeuger---verbraucher-problem">Erzeuger- / Verbraucher-Problem</h3>
<ul>
<li>Erzeuger-Prozess (<em>producer</em>) erzeugt Daten und schreibt sie in einen Puffer mit <code>N</code> Speicherplätzen</li>
<li>Verbraucher-Prozess (<em>consumer</em>) liest Daten aus Puffer mit unterschiedlicher Geschwindigkeit</li>
</ul>
<p><strong>1. Idee</strong>: Realisierung eines gegenseitigen Ausschlusses mit Semaphor <code>mutex = 1</code><br>
<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> unsicher, da Deadlocks auftreten können</p>
<p><strong>2. Idee</strong>: Verwendung weiteres Semaphors für</p>
<ol>
<li>die Anzahl belegter Speicherplätze <code>used</code></li>
<li>die Anzahl freier Speicherplätze <code>free</code></li>
</ol>
<h3 id="bewertung-des-semaphor-konzepts">Bewertung des Semaphor-Konzepts</h3>

<table>
<thead>
<tr>
<th align="left">Vorteile</th>
<th align="left">Nachteile</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">+ mächtiges Konzept</td>
<td align="left">- teils schwierige Suche nach korrekter Lösung</td>
</tr>
<tr>
<td align="left">+ flexibel</td>
<td align="left">- Verklemmungen zwischen Prozessen ist möglich</td>
</tr>
<tr>
<td align="left">+ vielseitig</td>
<td align="left">- unübersichtlich (<code>P</code> und <code>V</code> im Code verstreut)</td>
</tr>
<tr>
<td align="left">+ einfache Realisierung</td>
<td align="left">- leichte Programmierfehler durch Vertauschungen</td>
</tr>
</tbody>
</table><ul>
<li>ein <strong>Monitor</strong> ist ein abstrakter Datentyp, mit dem eine Synchronisation von Prozessen auf höherer Ebene stattfinden kann</li>
</ul>
<h3 id="kommunikation-mittels-nachrichten">Kommunikation mittels Nachrichten</h3>
<p><strong>2 Kommunikationsroutinen</strong>:</p>
<ul>
<li><code>send(destination, message)</code>: Senden einer Nachricht <code>message</code> an den Empfänger <code>destination</code></li>
<li><code>message = receive(source)</code>: Empfangen einer Nachricht vom Sender <code>source</code></li>
</ul>
<p>Empfänger-Prozess blockiert, falls er keine Nachricht empfängt, und wartet auf eine Nachricht. Sender und Empfänger können sich auf demselben Rechner oder auf getrennten Rechnern befinden.</p>
<p>Der Nachrichtenkanal wird als unsicher angesehen:</p>
<ol>
<li>Empfänger bestätigt Empfang einer Nachricht.</li>
<li>Falls Sender nach einer vorgegebenen Zeitspanne keine Empfangsbestätigung erhält, wiederholt er das Senden der Nachricht.</li>
<li>Empfänger muss nun die wiederholte Nachricht empfangen, da auch die Bestätigung verlorengehen kann.</li>
</ol>
<p><strong>Verschiedene Arbeitsweisen</strong>:</p>
<ul>
<li><strong>synchrones</strong> Senden einer Nachricht blockiert den Sender, bis eine Bestätigung eintrifft</li>
<li><strong>asynchrones</strong> Senden einer Nachricht blockiert den Sender nicht, d.h. Sender arbeitet normal weiter
<ul>
<li>Betriebssystem puffert gesendete Nachrichten, die noch nicht empfangen wurden</li>
</ul>
</li>
</ul>
<h3 id="verklemmungen-deadlocks">Verklemmungen (<em>Deadlocks</em>)</h3>
<ul>
<li>jede Situation, in der Prozesse <strong>exklusiv</strong> auf Ressourcen (Variablen) zugreifen, kann eine Verklemmung auslösen</li>
<li>Für das Auftreten einer Verklemmung müssen 4 Bedingungen erfüllt sein:
<ol>
<li>Exklusive Nutzung (<em>Mutual Exclusion</em>)</li>
<li>Wartebedingung (<em>Hold &amp; Wait</em>)</li>
<li>Nichtentziehbarkeit (<em>Non-Preemption</em>)</li>
<li>Geschlossene Kette (<em>Circular Wait</em>)</li>
</ol>
</li>
</ul>
<h2 id="speicherverwaltung">Speicherverwaltung</h2>
<h3 id="zu-bewältigende-aufgaben">Zu bewältigende Aufgaben</h3>
<ul>
<li>Bereitstellung von Adressräumen</li>
<li>Verwaltung des Hauptspeichers als Betriebsmittel</li>
<li>Schutz vor unerlaubten Zugriffen</li>
<li>Organisation der Nutzung eines gemeinsamen Speicherbereiches</li>
</ul>
<p>Die Speicherverwaltung ist die Komponente, die Prozessen einen Bereich im Hauptspeicher (<strong>Kachel</strong>) zuweist. Der Arbeitsspeicher eines Systems aus <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.05764em;">S</span></span></span></span></span> Worten wird eingeteilt in <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi>S</mi></mrow><mrow><mi>K</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\frac{S}{K}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.872331em;"></span><span class="strut bottom" style="height: 1.21733em; vertical-align: -0.345em;"></span><span class="base"><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.872331em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.07153em;">K</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line hide-tail" style="height: 0.04em;"><svg width="400em" height="400em" viewBox="0 0 400000 400000" preserveAspectRatio="xMinYMin slice"><path d="M0 0 h400000 v400000 h-400000z M0 0 h400000 v400000 h-400000z"></path></svg></span></span><span class="" style="top: -3.394em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathit mtight" style="margin-right: 0.05764em;">S</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span> Seiten aus jeweils <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi><mo>=</mo><mn>2</mn><mtext>k</mtext></mrow><annotation encoding="application/x-tex">K = 2\text{k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.69444em;"></span><span class="strut bottom" style="height: 0.69444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.07153em;">K</span><span class="mrel">=</span><span class="mord mathrm">2</span><span class="mord text"><span class="mord mathrm">k</span></span></span></span></span></span> Worten (typisch 4 Kbyte). Das Betriebssystem wird beim Startvorgang durch das BIOS (<em>Basic Input Output System</em>) in die ersten Kacheln des Hauptspeichers geladen. Die Anwendungsprogramme finden in den übrigen Kacheln Platz.</p>
<h3 id="speicherpartitionierung-und-fragmentierung">Speicherpartitionierung und Fragmentierung</h3>
<p>Ein Anwendungsprogramm benötigt einen zusammenhängenden Speicherbereich (u.U. eine Partition benachbarter Seiten). Durch die Speicherverwaltung werden nur ganze Seiten vergeben, was zu <strong>interner Fragmentierung</strong> führen kann (siehe Abbildung 9).</p>
<p><img src="images/intern-fragmentation.png" alt="Beispiel einer internen Fragmentierung"><br>
<em>Abbildung 9: Beispiel einer internen Fragmentierung</em></p>
<p><strong>2 Arten der Speicheraufteilung</strong>:</p>
<ul>
<li><strong>feste Partitionen</strong>: Speicher ist unterteilt in mehrere Partitionen fester Größe, jeder neue Prozess bekommt die kleinste ausreichende Partition zugewiesen
<ul>
<li>Problem: große Partitionen bleiben ungenutzt oder sind durch kleine Prozesse belegt</li>
</ul>
</li>
<li><strong>variable Partitionen</strong>: dynamisch variierende Anzahl und Größe der Partitionen
<ul>
<li>Problem: Ersetzung von Partitionen lässt viele kleine freie Speicherbereiche entstehen (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> <strong>externe Fragmentierung</strong>) und größere Prozesse können nicht mehr eingeordnet werden</li>
</ul>
</li>
</ul>
<h3 id="prozesseinordnungsalgorithmen">Prozesseinordnungsalgorithmen</h3>
<p><strong>Ziel</strong>: Minimierung des Verschnitts, damit nicht mehr so viele kleine freie Bereiche entstehen</p>
<p>Da die Suche nach einer freien Partition über die Belegungstabelle sehr aufwendig ist, bedient man sich einer verketteten <strong>Freiliste</strong>, die alle freien Partitionen beinhaltet und das Zusammenführen benachbarter freier Bereiche zulässt.</p>
<p>Folgende Algorithmen suchen nach dem geringstmöglichen Verschnitt:</p>
<ul>
<li><em>First fit</em>
<ul>
<li>Durchsuchen der Freiliste von Anfang an</li>
<li>Auswahl des ersten gefundenen Bereichs, der groß genug ist</li>
</ul>
</li>
<li><em>Best fit</em>
<ul>
<li>Durchsuchen der Freiliste von Anfang an</li>
<li>Auswahl des Bereichs mit der kleinsten ausreichenden Lücke</li>
</ul>
</li>
<li><em>Buddy system</em>
<ul>
<li>dynamische Auswahl mithilfe mehrerer Freilisten abhängig von Seitengröße <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.849108em;"></span><span class="strut bottom" style="height: 0.849108em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.849108em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight" style="margin-right: 0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span></span> und Blockgröße <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>s</mi></msup></mrow><annotation encoding="application/x-tex">2^s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.664392em;"></span><span class="strut bottom" style="height: 0.664392em; vertical-align: 0em;"></span><span class="base"><span class="mord"><span class="mord mathrm">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.664392em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathit mtight">s</span></span></span></span></span></span></span></span></span></span></span></span></li>
</ul>
</li>
</ul>
<h3 id="swapping">Swapping</h3>
<p>Falls der Arbeitsspeicher als Einlagerungsressource für Prozesse nicht ausreicht, fängt das Betriebssystem an, ganze Prozesse auf die Festplatte auszulagern. Dies kostet viel Zeit und die Prozesse auf dem Massenspeicher verlangsamen sich bei einer Transferrate von <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>≤</mo><mn>1</mn><mn>0</mn><mtext>&nbsp;</mtext><mtext>MB/s</mtext></mrow><annotation encoding="application/x-tex">\le 10 \ \text{MB/s}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.75em;"></span><span class="strut bottom" style="height: 1em; vertical-align: -0.25em;"></span><span class="base"><span class="mrel">≤</span><span class="mord mathrm">1</span><span class="mord mathrm">0</span><span class="mord text"><span class="mspace">&nbsp;</span><span class="mord mathrm">MB/s</span></span></span></span></span></span>. Swapping ist sehr ineffizient, da immer ganze Prozesse aus- und eingelagert werden müssen. Außerdem bietet sich eine Speichergefährdung bei fehlerhafter Adressierung nach Relokation eines Prozesses, wodurch dieser die Daten anderer Prozesse manipulieren könnte.</p>
<h3 id="der-adressraum">Der Adressraum</h3>
<p><strong>Begriff</strong>: Der Begriff <strong>Adressraum</strong> beschreibt die Menge an erreichbaren Adressen in einem bestimmten Speicher. Sie wird durch die Rechnerarchitektur vorgegeben.</p>
<p><strong>Physischer Adressraum</strong>: ein durch Adressleitungen gebildeter Adressraum, referenziert den physikalischen Hauptspeicher, bildet die Prozessoradressen auf die Speicherbausteine und die E/A-Ports ab</p>
<p><strong>Virtueller (logischer) Adressraum</strong>: Adressraum für Prozesse, Umrechung der virtuellen Adressen in physikalische Adressen durch <em>Memory Management Unit</em> (MMU) (siehe Abbildung 10)</p>
<p><img src="images/physical-address-conversion.png" alt="Konvertierung einer virtuellen in eine physikalische Adresse"><br>
<em>Abbildung 10: Konvertierung einer virtuellen in eine physikalische Adresse</em></p>
<h3 id="virtueller-speicher">Virtueller Speicher</h3>
<p><strong>Grundidee</strong>: Zuordnung von Speicherobjekten (Prozessdaten) zu Regionen von Adressräumen (siehe Abbildung 11)</p>
<ul>
<li>strikte Trennung von virtuellem und physikalischem Speicher</li>
<li>hardwarebasierte Abbildung von virtuellen auf physikalische Adressen</li>
<li>virtueller Adressraum ist in <strong>Seiten</strong> (<em>pages</em>) und physikalischer Speicher in gleich große <strong>Kacheln</strong> (<em>frames</em>) aufgeteilt
<ul>
<li>Zuordnung von Seiten zu Kacheln durch <strong>Seitenverzeichnis</strong></li>
<li>Seiten im virtuellen zusammenhängenden Adressraum werden auf <strong>nicht zusammenhängende</strong> Kacheln des physikalischen Speichers abgebildet</li>
</ul>
</li>
<li><strong>Seitenfehler</strong> bei unberechtigtem Zugriff auf Kachel oder wenn Seite keine Kachel zugeordnet wurde</li>
<li>jeder Prozess besitzt eine eigene <strong>Seitentabelle</strong>, die für jede Seite die Adresse der zugeordneten Kachel festhält</li>
</ul>
<p><strong>Ziel</strong>: jedem Prozess wird ein vom Hauptspeicher unabhängiger logischer Adressraum bereitgestellt</p>
<p>Betriebssystem kümmert sich um</p>
<ul>
<li>Seitenfehler</li>
<li>Verwaltung des Hauptspeichers</li>
<li>Aufbau der Adressraumstruktur</li>
<li>Bereitstellung spezifischer Speicherobjekte</li>
</ul>
<p><img src="images/virtual-memory-constellation.png" alt="Anordnung des virtuellen Speichers"><br>
<em>Abbildung 11: Anordnung des virtuellen Speichers</em></p>
<h3 id="adressabbildung">Adressabbildung</h3>
<ul>
<li>höherwertige Bits der virtuellen Adresse (rot) geben Seitennummer in Seitentabelle an</li>
<li>niedrigwertigere Bits der virtuellen Adresse (grün) bilden den sogenannten <em>Offset</em> (Wortadresse in Kachel) (siehe Abbildung 12)</li>
</ul>
<p><img src="images/virtual-address-transformation.png" alt="Kodierung der virtuellen Adresse"><br>
<em>Abbildung 12: Kodierung der virtuellen Adresse</em></p>
<ul>
<li>Präsenzbit <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>p</mi></mrow><annotation encoding="application/x-tex">p</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.43056em;"></span><span class="strut bottom" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="base"><span class="mord mathit">p</span></span></span></span></span> gibt an, ob die Seite in den Hauptspeicher geladen wurde oder nicht.</li>
<li>Seitentabelle kann noch Referenzbit <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.00773em;">R</span></span></span></span></span>, Modifikationsbit <span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>M</mi></mrow><annotation encoding="application/x-tex">M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.68333em;"></span><span class="strut bottom" style="height: 0.68333em; vertical-align: 0em;"></span><span class="base"><span class="mord mathit" style="margin-right: 0.10903em;">M</span></span></span></span></span> (gibt an, ob die Seite im Hauptspeicher verändert wurde) und Zugriffsbits (Berechtigungen) enthalten</li>
</ul>
<h3 id="die-seitentabelle">Die Seitentabelle</h3>
<p>Ein Seitentabelleneintrag kann folgendermaßen aussehen:</p>
<p><img src="images/entry-page-table.png" alt="Beispiel eines Seitentabelleneintrages"><br>
<em>Abbildung 13: Beispiel eines Seitentabelleneintrages</em></p>
<p><strong>Seitentabellenattribute</strong>:</p>
<ul>
<li><strong>present</strong>: Seite befindet sich im Hauptspeicher</li>
<li><strong>modified</strong>: schreibender Zugriff ist erfolgt (<em>“dirty”</em>)</li>
<li><strong>used</strong>: irgendein Zugriff ist erfolgt</li>
<li><strong>caching</strong>: ein/aus (z.B. wegen E/A)</li>
<li><strong>protection</strong>: erlaubte Art von Zugriffen in Abhängigkeit von CPU-Modus</li>
</ul>
<h3 id="seitenwechselstrategien">Seitenwechselstrategien</h3>
<p><strong>Einlagerungsstrategien</strong>:</p>
<ul>
<li><em>Pre-paging</em>
<ul>
<li>vorgeplante Einlagerung einer Seite, bevor sie von Programm adressiert wird</li>
</ul>
</li>
<li><em>Demand-paging</em>
<ul>
<li>Seiten werden nur durch Unterbrechungen nach Seitenfehlern geladen</li>
</ul>
</li>
</ul>
<p><strong>Auslagerungsstrategien</strong>:</p>
<ul>
<li><em>Random</em>
<ul>
<li>Es wird eine zufällige Seite ausgelagert</li>
</ul>
</li>
<li><em>First in, First out</em> (FIFO)
<ul>
<li>Es wird stets die Seite, die als erstes hinzugefügt wurde, ausgelagert</li>
</ul>
</li>
<li><em>Least Recently Used</em> (LRU)
<ul>
<li>Es wird die Seite ausgelagert, die am längsten nicht mehr benutzt wurde (UNIX)</li>
</ul>
</li>
<li><em>Least Frequently Used</em> (LFU)
<ul>
<li>Es wird die Seite ausgelagert, die am seltensten benutzt wurde</li>
</ul>
</li>
<li><em>Optimal Replacement</em>
<ul>
<li>Es wird die Seite ausgelagert, die am spätesten in der Zukunft wiederverwendet wird.</li>
</ul>
</li>
</ul>
<h3 id="bewertung-des-virtuellen-speichers">Bewertung des virtuellen Speichers</h3>

<table>
<thead>
<tr>
<th align="left">Vorteile</th>
<th align="left">Nachteile</th>
</tr>
</thead>
<tbody>
<tr>
<td align="left">+ geringe E/A-Belastung</td>
<td align="left">- hoher Speicherbedarf für Seitentabellen</td>
</tr>
<tr>
<td align="left">+ automatischer Speicherschutz: jeder Prozess kann nur auf seine eigenen Seiten zugreifen</td>
<td align="left">- hoher Implementierungsaufwand</td>
</tr>
<tr>
<td align="left">+ beliebig große Prozesse ausführbar</td>
<td align="left">- hoher CPU-Bedarf für Seitenverwaltung, falls keine Hardware-Unterstützung</td>
</tr>
<tr>
<td align="left">+ keine externe Fragmentierung</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">+ dynamischer Speicherplatz</td>
<td align="left"></td>
</tr>
</tbody>
</table><ul>
<li>Größe der Seitentabelle oder Geschwindigkeit der Abbildung können zum Problem werden</li>
</ul>
<h2 id="dateien-und-dateisysteme">Dateien und Dateisysteme</h2>
<p><strong>Problem</strong>: Größe vom Hauptspeicher ist begrenzt, Daten gehen verloren, sobald der Prozess beendet wird</p>
<p><strong>Lösung</strong>: Sicherung der Daten auf dem permanenten Massenspeicher mit großer Kapazität</p>
<p>Betriebssystem muss bei Dateien auf dem Massenspeicher darauf achten, dass</p>
<ul>
<li>ein effizienter und schneller Zugriff gewährleistet ist und</li>
<li>andere Benutzer nicht auf meine Dateien zugreifen können (Zugriffsberechtigungen).</li>
</ul>
<h3 id="massenspeicher--hintergrundspeicher">Massenspeicher / Hintergrundspeicher</h3>
<ul>
<li>physikalisches Medium mit Blockstruktur</li>
<li>4 oder 8 Blöcke bilden ein Cluster (siehe Abbildung 13)</li>
</ul>
<p><img src="images/hard-drive-cluster.png" alt="Clustering des Hintergrundspeichers"><br>
<em>Abbildung 13: Clustering des Hintergrundspeichers</em></p>
<h3 id="datei-konzept">Datei-Konzept</h3>
<p><strong>Datei</strong>: Eine mit Namen versehene Sammlung zusammengehöriger Informationen</p>
<ul>
<li>verschiedene Dateitypen (Textdatei, Quelltext, Bitmap, Binärdatei, Programmdatei, …)</li>
<li>Dateiattribute
<ul>
<li>Dateiname</li>
<li>Datei-Identifikator</li>
<li>Typinformationen, Format</li>
<li>Metadaten (Tabelle mit Informationen zur Datei)</li>
</ul>
</li>
<li>Datei-Operationen
<ul>
<li>Erzeugen</li>
<li>Schreiben</li>
<li>Lesen</li>
<li>Löschen</li>
<li>Umbenennen</li>
<li>Kopieren</li>
<li>Anhängen</li>
</ul>
</li>
<li>Operationen erfordern das Auffinden einer Datei in einem Verzeichnis (<em>Open File Table</em> (OFT) enthält eine Liste aller offenen Dateien)</li>
<li>Zugriffsarten
<ul>
<li>Sequenzieller Zugriff</li>
<li>Direkter Zugriff (<em>Direct Access</em>)</li>
</ul>
</li>
</ul>
<h3 id="verzeichniskonzept">Verzeichniskonzept</h3>
<p>Alle Dateien in einem Dateisystem werden durch optionale Partitionen auf der Festplatte und durch Verzeichnisse organisiert (siehe Abbildung 14).</p>
<p><img src="images/hard-drive-partitioning.png" alt="Organisation von Dateien auf Festplatten"><br>
<em>Abbildung 14: Organisation von Dateien auf Festplatten</em></p>
<p>Verzeichnisse bilden eine Struktur auf der Festplatte, unter der Dateien gespeichert werden können. In Verzeichnissen kann man</p>
<ul>
<li>nach einer Datei suchen</li>
<li>eine Datei anlegen</li>
<li>eine Datei löschen</li>
<li>eine Datei umbenennen</li>
<li>Dateien auflisten</li>
</ul>
<h3 id="verschiedene-varianten-von-verzeichnissen">Verschiedene Varianten von Verzeichnissen</h3>
<ul>
<li><strong>Single-Level-Verzeichnis</strong>: Alle Dateien in einem Verzeichnis<br>
<img src="images/single-level-directory.png" alt="Single-Level-Verzeichnis"><br>
<em>Abbildung 15: Single-Level-Verzeichnis</em></li>
<li><strong>Two-Level-Verzeichnis</strong>: Struktur mit zwei Ebenen, wobei jeder Benutzer sein eigenes Verzeichnis hat<br>
<img src="images/two-level-directory.png" alt="Two-Level-Verzeichnis"><br>
<em>Abbildung 16: Two-Level-Verzeichnis</em></li>
<li><strong>Baum-Verzeichnisstruktur</strong>: Struktur mit Verzeichnissen und beliebig vielen Unterverzeichnissen, Datei wird über absoluten Pfad vom Wurzelverzeichnis (unter UNIX <code>/</code>) identifiziert<br>
<img src="images/tree-directory.png" alt="Baum-Verzeichnisstruktur"><br>
<em>Abbildung 17: Baum-Verzeichnisstruktur</em></li>
</ul>
<h3 id="operationen-auf-dateisystemen">Operationen auf Dateisystemen</h3>
<ul>
<li>Dateien oder Verzeichnisse können über Links an mehreren Stellen referenziert werden (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> azyklische Graphen / Referenzierung)</li>
<li>andere Dateisysteme können in das Aktuelle an einen bestimmten Punkt eingehängt werden (<em>mount</em>)</li>
</ul>
<h3 id="implementierung-auf-festplatten">Implementierung auf Festplatten</h3>
<ul>
<li>Dateien werden magnetisch gespeichert</li>
<li>Festplatte besteht aus
<ul>
<li>Scheiben und Schreib- / Leseköpfen (beidseitig)</li>
<li>Scheiben bestehen aus Spuren (<em>Tracks</em>)</li>
<li>Spuren sind in Sektoren aufgeteilt (siehe Abbildung 18)</li>
</ul>
</li>
<li>Scheiben werden durch <em>spindle</em> rotiert</li>
<li>um den Durchsatz zu erhöhen, werden Daten blockweise übertragen (Block = mehrere Sektoren)</li>
<li>Zugriffe werden durch Gerätecontroller (<em>disk controller</em>) gesteuert</li>
</ul>
<p><img src="images/hard-drive-composition.png" alt="Aufbau einer Festplatte"><br>
<em>Abbildung 18: Aufbau einer Festplatte</em></p>
<h3 id="implementierung-von-dateisystemen">Implementierung von Dateisystemen</h3>
<p>Dateisysteme sind in Schichten realisiert:</p>
<ul>
<li><strong>E/A-Kontrolle</strong>: Treiber für Datenübertragung</li>
<li><strong>Basic File System</strong>: veranlasst Treiber, physikalische Blöcke auf Festplatte zu schreiben bzw. von dort zu lesen</li>
<li><strong>Dateiorganisationsmodul</strong>: Abbildung von logischen zu physikalischen Blockadressen</li>
<li><strong>Logisches Dateisystem</strong>: Neueintragung / Löschung von Dateien sowie E/A-Zugriffe auf eine Datei</li>
</ul>

<table>
<thead>
<tr>
<th align="center">Schichten</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Anwendungsprogramme</td>
</tr>
<tr>
<td align="center">logisches Dateisystem</td>
</tr>
<tr>
<td align="center">Dateiorganisationsmodul</td>
</tr>
<tr>
<td align="center">Basic-File-System</td>
</tr>
<tr>
<td align="center">E/A-Kontrolle</td>
</tr>
<tr>
<td align="center">Hardware</td>
</tr>
</tbody>
</table><p><img src="images/hard-drive-segments.png" alt="Segmente einer Festplatte"><br>
<em>Abbildung 19: Segmente einer Festplatte</em></p>
<ul>
<li><em>Master Boot Record</em> (MBR) liegt immer im ersten Segment der Festplatte (Sektor 0)
<ul>
<li>enthält die Anfangs- und Endadressen jeder Partition</li>
<li>Beim Boot-Vorgang wird der MBR vom BIOS (<em>Basic Input Output System</em>) ausgeführt</li>
</ul>
</li>
<li><strong>Superblock</strong> (oder <em>Volume Control Block</em>)
<ul>
<li>enthält wichtige Parameter des Dateisystems</li>
</ul>
</li>
</ul>
<h3 id="allokationsstrategien-vom-dateisystem">Allokationsstrategien vom Dateisystem</h3>
<p>Ein Dateisystem kann zwischen verschiedenen Möglichkeiten wählen, Blöcke von Daten wie Dateien auf die Festplatte zu schreiben:</p>
<ul>
<li>zusammenhängende Belegung</li>
<li>verkettete Belegung</li>
<li>Belegung durch verkettete Listen mit einer Tabelle im Arbeitsspeicher (<span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\rightarrow</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.36687em;"></span><span class="strut bottom" style="height: 0.36687em; vertical-align: 0em;"></span><span class="base"><span class="mrel">→</span></span></span></span></span> <strong>indizierte Allokation</strong>)</li>
</ul>
<h4 id="zusammenhängende-belegung">Zusammenhängende Belegung</h4>
<p><img src="images/filesystem-consecutive-allocation.png" alt="Zusammenhängende Block-Allokation"><br>
<em>Abbildung 20: Zusammenhängende Block-Allokation</em></p>
<p><strong>Zugehörige Struktur des Verzeichnisses</strong></p>

<table>
<thead>
<tr>
<th align="center">Datei</th>
<th align="center">Start</th>
<th align="center">Länge</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">Name1</td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">0</span></span></span></span></span></td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span></span></span></span></span></td>
</tr>
<tr>
<td align="center">Name2</td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>4</mn></mrow><annotation encoding="application/x-tex">14</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord mathrm">4</span></span></span></span></span></td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>3</mn></mrow><annotation encoding="application/x-tex">3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">3</span></span></span></span></span></td>
</tr>
<tr>
<td align="center">Name3</td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>1</mn><mn>9</mn></mrow><annotation encoding="application/x-tex">19</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">1</span><span class="mord mathrm">9</span></span></span></span></span></td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">6</span></span></span></span></span></td>
</tr>
<tr>
<td align="center">Name4</td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn><mn>8</mn></mrow><annotation encoding="application/x-tex">28</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span><span class="mord mathrm">8</span></span></span></span></span></td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>4</mn></mrow><annotation encoding="application/x-tex">4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">4</span></span></span></span></span></td>
</tr>
<tr>
<td align="center">Name6</td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>6</mn></mrow><annotation encoding="application/x-tex">6</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">6</span></span></span></span></span></td>
<td align="center"><span class="katex--inline"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="strut" style="height: 0.64444em;"></span><span class="strut bottom" style="height: 0.64444em; vertical-align: 0em;"></span><span class="base"><span class="mord mathrm">2</span></span></span></span></span></td>
</tr>
</tbody>
</table><h4 id="verkettete-belegung">Verkettete Belegung</h4>
<p><img src="images/filesystem-linked-allocation.png" alt="Verkettete Block-Allokation"><br>
<em>Abbildung 21: Verkettete Block-Allokation</em></p>
<ul>
<li>Verzeichniseintrag enthält Zeiger auf den ersten und letzten Block der Datei und ihre Länge</li>
<li>jeder Block hat einen Zeiger auf den nachfolgenden Block</li>
<li>auch als doppelt verkettete Liste möglich (jeder Block hat einen Zeiger auf den vorherigen Block)</li>
</ul>
<h4 id="indizierte-belegung">Indizierte Belegung</h4>

